#! /usr/bin/env python

# SPDX-FileCopyrightText: 2020 - 2023 sudorook <daemon@nullcodon.com>
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program. If not, see <https://www.gnu.org/licenses/>.

""" docstring """

import argparse
import os
import sys
import random

from Bio.Align import MultipleSeqAlignment

import dcatools as tools


def parse_options():
    """cli parser"""
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-n",
        "--msa_numeric",
        dest="msa_numeric",
        required=False,
        help="numerical msa file",
    )
    parser.add_argument(
        "-i",
        "--msa",
        dest="msa",
        required=False,
        help="fasta msa file",
    )
    parser.add_argument(
        "-c",
        "--count",
        dest="count",
        required=True,
        help="number of sequences to sample",
    )
    parser.add_argument(
        "-s",
        "--seed",
        dest="seed",
        default=0,
        required=False,
        help="random seed",
    )
    parser.add_argument(
        "-o",
        "--output",
        dest="output",
        required=True,
        help="output file",
    )
    parser.add_argument(
        "-r",
        "--save_remainder",
        dest="remain",
        action="store_true",
        default=False,
        help="save remainder of sequences",
    )
    return parser.parse_args()


def main():
    """Randomly subsample a MSA."""
    options = parse_options()

    prefix, ext = os.path.splitext(options.output)

    if options.msa:
        alignment = tools.load_alignment_fasta(options.msa)
    elif options.msa_numeric:
        alignment = tools.load_sequences(options.msa_numeric)
    else:
        sys.stderr.write("No input MSA.")
        sys.exit(3)

    M = len(alignment)
    N = len(alignment[0])
    Q = 21
    count = int(options.count)

    random.seed(options.seed)

    idx = list(range(0, len(alignment)))
    random.shuffle(idx)

    if options.msa:
        shuf_align = MultipleSeqAlignment([alignment[i] for i in idx[0:count]])
        tools.save_alignment_fasta(shuf_align, options.output)

        if options.remain:
            shuf_remain = MultipleSeqAlignment(
                [alignment[i] for i in idx[count:M]]
            )
            tools.save_alignment_fasta(shuf_remain, prefix + "_remain" + ext)
    elif options.msa_numeric:
        shuf_align = alignment[idx[0:count], :]
        tools.save_alignment(shuf_align, count, N, Q, options.output)
        if options.remain:
            shuf_remain = alignment[idx[count:M], :]
            tools.save_alignment(
                shuf_remain, M - count, N, Q, prefix + "_remain" + ext
            )


if __name__ == "__main__":
    main()
